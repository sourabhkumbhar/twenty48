<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>2048</title>
<style>
  :root { --bg:#bbada0; --cell:#cdc1b4; --card:#8f7a66; --txt:#776e65; --white:#fff; }
  html,body { height:100%; margin:0; font-family: system-ui, -apple-system, Roboto, Arial; background:#faf8ef; color:var(--txt); }
  .wrap { max-width:520px; margin:16px auto; padding:0 12px; text-align:center; }
  h1 { margin:0 0 8px 0; font-size:36px; }
  .scores { display:flex; gap:8px; justify-content:center; margin:8px 0 12px; }
  .chip { background:var(--card); color:var(--white); border-radius:8px; padding:8px 14px; }
  .grid { margin:0 auto; background:var(--bg); border-radius:12px; padding:8px; touch-action:none; }
  .row { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .cell { border-radius:8px; height:0; padding-bottom:100%; position:relative; background:var(--cell); }
  .tile { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; 
          font-weight:800; border-radius:8px; font-size:32px; transition:transform .08s ease, background .1s ease; }
  .bar { display:flex; justify-content:center; gap:8px; margin-top:12px; }
  button { padding:10px 14px; border-radius:8px; border:0; background:#edc53f; cursor:pointer; font-weight:700; }
  .hint { font-size:13px; opacity:.7; margin-top:8px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>2048</h1>
    <div class="scores">
      <div class="chip">Score: <span id="score">0</span></div>
      <div class="chip">Best: <span id="best">0</span></div>
    </div>
    <div id="board" class="grid" aria-label="Game board"></div>
    <div class="bar">
      <button id="up">↑</button>
      <button id="left">←</button>
      <button id="down">↓</button>
      <button id="right">→</button>
      <button id="new">New</button>
      <button id="undo">Undo</button>
    </div>
    <div class="hint">Swipe or use buttons. Reach 2048.</div>
  </div>

<script>
(() => {
  const size = 4;
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const btn = {
    up: document.getElementById('up'),
    down: document.getElementById('down'),
    left: document.getElementById('left'),
    right: document.getElementById('right'),
    new: document.getElementById('new'),
    undo: document.getElementById('undo'),
  };

  let board, score, best = +localStorage.getItem('best_2048') || 0;
  let prevBoard = null, prevScore = 0;

  function newBoard() {
    board = Array.from({length:size}, ()=> Array(size).fill(0));
    score = 0;
    addRandom(); addRandom();
    render();
  }

  function backup() {
    prevBoard = board.map(r => r.slice());
    prevScore = score;
  }

  function undo() {
    if (!prevBoard) return;
    board = prevBoard.map(r => r.slice());
    score = prevScore;
    render();
  }

  function addRandom() {
    const empty = [];
    for (let r=0;r<size;r++) for (let c=0;c<size;c++) if (!board[r][c]) empty.push([r,c]);
    if (!empty.length) return;
    const [r,c] = empty[Math.floor(Math.random()*empty.length)];
    board[r][c] = Math.random() < 0.9 ? 2 : 4;
  }

  function canMove() {
    for (let r=0;r<size;r++) for (let c=0;c<size;c++) {
      const v = board[r][c];
      if (!v) return true;
      if (r+1<size && board[r+1][c] === v) return true;
      if (c+1<size && board[r][c+1] === v) return true;
    }
    return false;
  }

  function move(dir) {
    backup();
    let moved = false;
    const getLine = (i) => {
      if (dir==='left')  return board[i].slice();
      if (dir==='right') return board[i].slice().reverse();
      if (dir==='up')    return board.map(r => r[i]);
      if (dir==='down')  return board.map(r => r[i]).reverse();
    };
    const setLine = (i, line) => {
      if (dir==='left')  board[i] = line;
      if (dir==='right') board[i] = line.slice().reverse();
      if (dir==='up')    for (let r=0;r<size;r++) board[r][i] = line[r];
      if (dir==='down')  { const rev=line.slice().reverse(); for (let r=0;r<size;r++) board[r][i]=rev[r]; }
    };

    for (let i=0;i<size;i++) {
      const line = getLine(i);
      const compacted = compact(line);
      if (!eq(line, compacted)) moved = true;
      setLine(i, compacted);
    }
    if (moved) {
      addRandom();
      if (!canMove()) setTimeout(()=>alert('Game over. Score: '+score), 10);
      render();
    }
  }

  function compact(line) {
    const tiles = line.filter(v=>v);
    const out = [];
    for (let i=0;i<tiles.length;i++) {
      if (i+1<tiles.length && tiles[i]===tiles[i+1]) {
        const merged = tiles[i]*2;
        out.push(merged);
        score += merged;
        if (score>best) { best = score; localStorage.setItem('best_2048', best); }
        i++;
      } else out.push(tiles[i]);
    }
    while (out.length<size) out.push(0);
    return out;
  }

  function eq(a,b){ if (a.length!==b.length) return false; for (let i=0;i<a.length;i++) if (a[i]!==b[i]) return false; return true; }

  function tileColor(v){
    const map = {
      0:'#cdc1b4',2:'#eee4da',4:'#ede0c8',8:'#f2b179',16:'#f59563',32:'#f67c5f',64:'#f65e3b',
      128:'#edcf72',256:'#edcc61',512:'#edc850',1024:'#edc53f',2048:'#edc22e'
    };
    return map[v] || '#edc22e';
  }
  function textColor(v){ return v<=4 ? '#776e65' : '#fff'; }

  function render() {
    scoreEl.textContent = score;
    bestEl.textContent = best;
    // square board sized to viewport
    const side = Math.min(window.innerWidth-24, 520);
    boardEl.style.width = side+'px';
    boardEl.style.height = side+'px';
    boardEl.innerHTML = '';
    for (let r=0;r<size;r++){
      const row = document.createElement('div');
      row.className='row';
      for (let c=0;c<size;c++){
        const cell = document.createElement('div'); cell.className='cell';
        const v = board[r][c];
        const tile = document.createElement('div');
        tile.className='tile';
        tile.style.background = tileColor(v);
        tile.style.color = textColor(v);
        tile.innerHTML = v? `<div style="transform:scale(1);">${v}</div>` : '';
        row.appendChild(cell);
        cell.appendChild(tile);
      }
      boardEl.appendChild(row);
    }
  }

  // Buttons
  btn.up.onclick    = ()=>move('up');
  btn.down.onclick  = ()=>move('down');
  btn.left.onclick  = ()=>move('left');
  btn.right.onclick = ()=>move('right');
  btn.new.onclick   = ()=>{ newBoard(); };
  btn.undo.onclick  = ()=>{ undo(); };

  // Keys
  window.addEventListener('keydown', e=>{
    const k=e.key;
    if (['ArrowUp','w','W'].includes(k)) move('up');
    else if (['ArrowDown','s','S'].includes(k)) move('down');
    else if (['ArrowLeft','a','A'].includes(k)) move('left');
    else if (['ArrowRight','d','D'].includes(k)) move('right');
  });

  // Touch swipe
  let startX=0,startY=0, moved=false;
  boardEl.addEventListener('touchstart', e=>{
    const t=e.changedTouches[0]; startX=t.clientX; startY=t.clientY; moved=false;
  }, {passive:true});
  boardEl.addEventListener('touchmove', ()=>{ moved=true; }, {passive:true});
  boardEl.addEventListener('touchend', e=>{
    if (!moved) return;
    const t=e.changedTouches[0];
    const dx=t.clientX-startX, dy=t.clientY-startY;
    const ax=Math.abs(dx), ay=Math.abs(dy);
    const threshold=24;
    if (Math.max(ax,ay)<threshold) return;
    if (ax>ay) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
  }, {passive:true});

  // Init
  bestEl.textContent = best;
  newBoard();
  window.addEventListener('resize', render);
})();
</script>
</body>
</html>
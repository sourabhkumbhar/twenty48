<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Neon Warp Tunnel â€“ WebGL Raymarch</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,Arial}
  #ui{position:fixed;left:10px;top:10px;color:#fff;font-size:14px;line-height:1.25;background:rgba(0,0,0,.35);padding:8px 10px;border-radius:8px}
  .row{display:flex;gap:8px;align-items:center;margin-top:6px}
  input[type=range]{width:140px}
  a{color:#9cf;text-decoration:none}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div id="ui">
  <div><b>Neon Warp Tunnel</b></div>
  <div>FPS: <span id="fps">0</span></div>
  <div class="row">
    Quality <input id="q" type="range" min="0.5" max="1.0" step="0.05" value="1.0">
    <span id="qv">1.0</span>x
  </div>
  <div class="row">
    Glow <input id="g" type="range" min="0.0" max="2.0" step="0.05" value="1.0">
    <span id="gv">1.0</span>
  </div>
  <div class="row">
    <button id="pause">Pause</button>
    <button id="screenshot">Shot</button>
  </div>
  <div>Drag to look, scroll to speed.</div>
</div>
<script>
(() => {
  const canvas = document.getElementById('gl');
  const fpsEl = document.getElementById('fps');
  const q = document.getElementById('q'), qv = document.getElementById('qv');
  const g = document.getElementById('g'), gv = document.getElementById('gv');
  const btnPause = document.getElementById('pause');
  const btnShot = document.getElementById('screenshot');

  const gl = canvas.getContext('webgl2', {antialias:false, powerPreference:'high-performance'});
  if(!gl){ alert('WebGL2 not supported'); return; }

  const vert = `#version 300 es
  precision highp float;
  const vec2 verts[3]=vec2[3](vec2(-1.,-1.),vec2(3.,-1.),vec2(-1.,3.));
  out vec2 vUV;
  void main(){
    vec2 p=verts[gl_VertexID];
    vUV=p;
    gl_Position=vec4(p*2.-1.,0,1);
  }`;

  // Fragment shader: Ray-marched twist tunnel + boxes + glow
  const frag = `#version 300 es
  precision highp float;
  out vec4 o;
  in vec2 vUV;
  uniform vec2 uRes;
  uniform float uTime;
  uniform vec2 uRot;   // camera yaw,pitch
  uniform float uSpeed;
  uniform float uGlowMul;
  uniform float uQuality;

  // Hash and noise
  float hash(vec3 p){ p=fract(p*0.3183099+0.1); p*=17.0; return fract(p.x*p.y*p.z*(p.x+p.y+p.z)); }

  // Rotation
  mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }

  // Signed distance functions
  float sdBox(vec3 p, vec3 b){
    vec3 d=abs(p)-b; return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
  }

  // Map: twisting tunnel with periodic boxes
  float map(vec3 p, out int matId){
    // Twist the world around Z
    float tw = 0.6*sin(p.z*0.2) + 0.3*sin(p.z*0.63);
    p.xy = rot(tw)*p.xy;

    // Main tunnel SDF: cylinder with ripples
    float r = length(p.xy) - (1.3 + 0.25*sin(p.z*1.6) + 0.15*sin(p.z*3.7));
    float tunnel = r;

    // Boxes along the tunnel
    vec3 q = p;
    float period = 6.0;
    q.z = mod(q.z, period) - period*0.5;
    float bx = sdBox(q - vec3(0.9,0.0,0.0), vec3(0.22,0.22,1.2));
    float by = sdBox(q - vec3(-0.9,0.0,0.0), vec3(0.22,0.22,1.2));
    float b = min(bx, by);

    // Combine
    float d = min(tunnel, b);
    matId = (d==tunnel)? 1 : 2;
    return d;
  }

  // Normal via gradient
  vec3 calcNormal(vec3 p){
    int m;
    const float e=0.001;
    vec2 k=vec2(1,-1);
    return normalize( k.xyy*map(p + k.xyy*e,m) + k.yyx*map(p + k.yyx*e,m)
                     +k.yxy*map(p + k.yxy*e,m) + k.xxx*map(p + k.xxx*e,m));
  }

  // Simple lighting + emissive stripes
  vec3 shade(vec3 p, vec3 rd, int matId){
    vec3 n = calcNormal(p);
    float diff = max(dot(n,normalize(vec3(0.4,0.7,0.2))),0.0);
    float fres = pow(1.0-max(dot(-rd,n),0.0),3.0);

    // Palette by material
    vec3 base = (matId==1) ? vec3(0.1,0.6,1.2) : vec3(1.2,0.4,0.2);

    // Neon stripe emissive
    float stripe = smoothstep(0.02,0.0,abs(sin(p.z*3.0)+0.2*sin(p.x*6.0)));
    vec3 emissive = base * stripe * 2.5;

    vec3 col = base*0.25 + diff*base*0.9 + fres*vec3(1.0);
    return col + emissive;
  }

  // Raymarch
  vec4 march(vec3 ro, vec3 rd){
    float t=0.0, glow=0.0;
    vec3 col = vec3(0.0);
    for(int i=0;i<180;i++){
      vec3 p = ro + rd*t;
      int matId;
      float d = map(p, matId);

      // accumulate glow from distance field
      glow += 0.02 / (0.02 + max(d,0.0));

      if(d<0.001){
        vec3 s = shade(p, rd, matId);
        col = s;
        break;
      }
      // adaptive step
      t += max(0.01, d*0.6);
      if(t>50.0) break;

      // cheap fog-tinted glow
      col += vec3(0.001)*exp(-0.02*t);
    }
    return vec4(col, glow);
  }

  // Tonemap
  vec3 tonemap(vec3 c){
    c = c*(1.0/ (1.0 + max(0.0, dot(c, vec3(0.25)))));
    return pow(clamp(c,0.0,1.0), vec3(0.9));
  }

  void main(){
    vec2 R = uRes;
    vec2 uv = (gl_FragCoord.xy*2.0 - R)/R.y;

    // Temporal jitter for cheap AA at lower quality
    float jitter = (fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453) - 0.5) * (1.0-uQuality)*0.8;
    uv += jitter * 0.002;

    // Camera
    float t = uTime;
    float camZ = t * uSpeed * 4.0;
    vec3 ro = vec3(0.0, 0.0, camZ);
    vec3 fwd = normalize(vec3(0.0,0.0,1.0));
    vec3 right = vec3(1.0,0.0,0.0);
    vec3 up = vec3(0.0,1.0,0.0);

    // apply mouse yaw/pitch
    right = right * rot(uRot.x);
    up = up * rot(uRot.x);
    fwd = normalize(vec3(0.0,0.0,1.0));
    // pitch around right
    mat2 Ry = rot(uRot.y);
    vec3 tmpU = up;
    up = vec3(up.x*Ry[0][0]+fwd.x*Ry[0][1], up.y*Ry[0][0]+fwd.y*Ry[0][1], up.z*Ry[0][0]+fwd.z*Ry[0][1]);
    fwd = normalize(cross(right, up));

    vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

    vec4 mr = march(ro, rd);
    vec3 col = mr.rgb;

    // Glow as additive bloom-ish
    float glow = mr.a * uGlowMul;
    col += glow*vec3(0.7,0.9,1.2);

    // Vignette
    float vig = smoothstep(1.2, 0.2, length(uv));
    col *= vig;

    col = tonemap(col);
    o = vec4(col,1.0);
  }`;

  function createShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s)); throw new Error('Shader compile failed');
    }
    return s;
  }
  function createProgram(vsSrc, fsSrc){
    const p = gl.createProgram();
    gl.attachShader(p, createShader(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, createShader(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p)); throw new Error('Link failed');
    }
    return p;
  }
  const prog = createProgram(vert, frag);
  gl.useProgram(prog);

  const loc = {
    uRes: gl.getUniformLocation(prog,'uRes'),
    uTime: gl.getUniformLocation(prog,'uTime'),
    uRot: gl.getUniformLocation(prog,'uRot'),
    uSpeed: gl.getUniformLocation(prog,'uSpeed'),
    uGlowMul: gl.getUniformLocation(prog,'uGlowMul'),
    uQuality: gl.getUniformLocation(prog,'uQuality'),
  };

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  let paused = false;
  let startTime = performance.now();
  let lastTime = startTime;
  let yaw = 0, pitch = 0;
  let speed = 1.0;
  let glowMul = parseFloat(g.value);
  let quality = parseFloat(q.value);

  q.oninput = ()=>{ quality=parseFloat(q.value); qv.textContent=q.value; resize(); };
  g.oninput = ()=>{ glowMul=parseFloat(g.value); gv.textContent=g.value; };
  btnPause.onclick = ()=>{ paused = !paused; btnPause.textContent = paused? 'Resume':'Pause'; };
  btnShot.onclick = ()=> {
    const link = document.createElement('a');
    link.download='neon_tunnel.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  };

  // mouse drag to look
  let dragging=false, lx=0, ly=0;
  window.addEventListener('mousedown', e=>{ dragging=true; lx=e.clientX; ly=e.clientY; });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', e=>{
    if(!dragging) return;
    const dx = e.clientX - lx, dy = e.clientY - ly;
    lx = e.clientX; ly = e.clientY;
    yaw += dx * 0.0025;
    pitch += dy * 0.0025;
    pitch = Math.max(-1.1, Math.min(1.1, pitch));
  }, {passive:true});

  // touch
  let tActive=false, tx=0, ty=0;
  window.addEventListener('touchstart', e=>{ const t=e.touches[0]; tActive=true; tx=t.clientX; ty=t.clientY; }, {passive:true});
  window.addEventListener('touchend', ()=> tActive=false, {passive:true});
  window.addEventListener('touchmove', e=>{
    if(!tActive) return;
    const t=e.touches[0];
    const dx=t.clientX-tx, dy=t.clientY-ty; tx=t.clientX; ty=t.clientY;
    yaw += dx*0.003; pitch += dy*0.003; pitch=Math.max(-1.1,Math.min(1.1,pitch));
  }, {passive:true});

  // scroll to change speed
  window.addEventListener('wheel', e=>{
    speed += e.deltaY>0? -0.1 : 0.1;
    speed = Math.max(0.1, Math.min(4.0, speed));
  }, {passive:true});

  function resize(){
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
    const qScale = quality;
    const w = Math.floor(window.innerWidth * dpr * qScale);
    const h = Math.floor(window.innerHeight * dpr * qScale);
    if(canvas.width!==w || canvas.height!==h){
      canvas.width=w; canvas.height=h;
    }
    canvas.style.width = window.innerWidth+'px';
    canvas.style.height = window.innerHeight+'px';
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  // render loop
  let frames=0, acc=0;
  function loop(now){
    const dt = (now - lastTime)/1000;
    lastTime = now;
    if(!paused){
      const t = (now - startTime)/1000;
      gl.useProgram(prog);
      gl.uniform2f(loc.uRes, canvas.width, canvas.height);
      gl.uniform1f(loc.uTime, t);
      gl.uniform2f(loc.uRot, yaw, pitch);
      gl.uniform1f(loc.uSpeed, speed);
      gl.uniform1f(loc.uGlowMul, glowMul);
      gl.uniform1f(loc.uQuality, quality);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    // fps
    frames++; acc += dt;
    if(acc >= 0.5){ fpsEl.textContent = Math.round(frames/acc); frames=0; acc=0; }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
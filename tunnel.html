<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Neon Tunnel Racer</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Roboto,Arial}
  canvas{display:block;width:100vw;height:100vh}
  #hud{position:fixed;left:0;top:0;width:100%;pointer-events:none;color:#fff}
  #score{position:absolute;left:12px;top:10px;font-weight:700;text-shadow:0 0 8px #000}
  #start{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:5}
  #btn{padding:14px 22px;border-radius:12px;border:0;background:#10d2ff;color:#001; font-weight:800;font-size:18px;box-shadow:0 8px 30px rgba(16,210,255,.45)}
  #tip{position:absolute;bottom:22px;width:100%;text-align:center;color:#bbb;font-size:14px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div id="score">0</div>
</div>
<div id="start">
  <button id="btn">Tap to Start</button>
  <div id="tip">Tilt to steer (or swipe). Pass through the gap.</div>
</div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl', {antialias:false, alpha:false, powerPreference:'high-performance'});
  if(!gl){ alert('WebGL not supported'); return; }

  // Minimal full-screen triangle program
  const vs = `
    attribute vec2 p;
    void main(){ gl_Position = vec4(p,0.,1.); }`;
  const fs = `
    precision highp float;
    uniform vec2 R;
    uniform float T;
    uniform float speed;
    uniform float gateAngle;
    uniform float gateWidth;
    uniform float playerAngle;

    // rotate 2D
    mat2 rot(float a){ float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }

    // simple palette
    vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){
      return a + b*cos(6.28318*(c*t+d));
    }

    void main(){
      // uv: screen coords centered
      vec2 uv = (gl_FragCoord.xy - 0.5*R) / R.y;

      // camera wobble for life
      float wob = 0.25*sin(T*0.7) + 0.15*cos(T*1.3);
      uv *= rot(wob);

      // polar coords for tunnel effect
      float r = length(uv);
      float ang = atan(uv.y, uv.x);                 // [-PI, PI]

      // scroll along tunnel with radial stripes
      float z = T*speed * 3.0;
      float rings = sin((1.0/r + z)*4.0);
      float twist = sin((ang*3.0) + z*0.8);

      // base neon color
      vec3 base = pal(rings*0.5+0.5,
                      vec3(0.08,0.1,0.12),
                      vec3(0.4,0.5,0.7),
                      vec3(0.5,0.2,0.2),
                      vec3(0.0,0.33,0.67));

      // vignette
      float vig = smoothstep(1.2, 0.1, r);

      // glow lines along tunnel
      float grid = 0.008 / (abs(sin(ang*6.0 + z)) + 0.02);
      vec3 glow = vec3(0.7, 0.9, 1.3) * grid;

      // gate visualization: draw a bright arc at gateAngle with width
      float dA = abs(ang - gateAngle);
      dA = min(dA, 6.28318 - dA);                   // wrap
      float arc = smoothstep(gateWidth, gateWidth*0.55, dA);
      vec3 gateCol = mix(vec3(1.1,0.9,0.2), vec3(0.1), arc);

      // player cursor line
      float dP = abs(ang - playerAngle); dP = min(dP, 6.28318 - dP);
      float cursor = smoothstep(0.03, 0.0, dP) * smoothstep(0.0, 0.5, r);
      vec3 cursorCol = vec3(1.3, 1.0, 0.8) * cursor;

      // compose
      vec3 col = base*vig + glow*0.7 + gateCol*0.9 + cursorCol;

      // slight bloom-y effect
      col += pow(max(col-0.7, 0.0), vec3(2.0))*0.6;

      gl_FragColor = vec4(pow(col, vec3(0.92)), 1.0);
    }`;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ throw new Error(gl.getProgramInfoLog(prog)); }
  gl.useProgram(prog);

  // full-screen triangle
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  const locP = gl.getAttribLocation(prog, 'p');
  gl.enableVertexAttribArray(locP);
  gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

  const uR = gl.getUniformLocation(prog, 'R');
  const uT = gl.getUniformLocation(prog, 'T');
  const uSpeed = gl.getUniformLocation(prog, 'speed');
  const uGateA = gl.getUniformLocation(prog, 'gateAngle');
  const uGateW = gl.getUniformLocation(prog, 'gateWidth');
  const uPlayerA = gl.getUniformLocation(prog, 'playerAngle');

  // game state
  let running = false;
  let last = performance.now();
  let t = 0;
  let score = 0;
  let speed = 1.0;
  let gateAngle = 0;
  let gateWidth = 0.7;        // radians, shrinks over time
  let playerAngle = 0;
  let wobble = 0;
  const scoreEl = document.getElementById('score');
  const startOverlay = document.getElementById('start');
  const btn = document.getElementById('btn');

  // resize with DPR cap for iPhone
  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    if(canvas.width!==w || canvas.height!==h){
      canvas.width = w; canvas.height = h;
      gl.viewport(0,0,w,h);
    }
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // controls: tilt or swipe
  let useTilt = false;
  function handleTilt(e){
    if(!running) return;
    // gamma: left/right tilt on iPhone in portrait
    const g = (e.gamma || 0); // [-90..90]
    playerAngle += (g/45) * 0.06;
    wrapPlayer();
  }
  function wrapPlayer(){
    const PI = Math.PI;
    if(playerAngle > PI) playerAngle -= 2*PI;
    if(playerAngle < -PI) playerAngle += 2*PI;
  }

  let dragging=false, lastX=0;
  canvas.addEventListener('touchstart', e=>{
    dragging = true; lastX = e.touches[0].clientX;
  }, {passive:true});
  canvas.addEventListener('touchmove', e=>{
    if(!dragging) return;
    const x = e.touches[0].clientX;
    const dx = x - lastX; lastX = x;
    playerAngle += dx * 0.0045;
    wrapPlayer();
  }, {passive:true});
  window.addEventListener('touchend', ()=> dragging=false, {passive:true});

  // start flow
  btn.addEventListener('click', async ()=>{
    startOverlay.style.display = 'none';
    score = 0; t = 0; speed = 1.0; gateWidth = 0.7; gateAngle = 0; playerAngle = 0;
    running = true;
    // iOS needs explicit permission for motion
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      try { const perm = await DeviceMotionEvent.requestPermission(); useTilt = perm === 'granted'; }
      catch(_) { useTilt = false; }
    } else if ('DeviceOrientationEvent' in window) {
      useTilt = true;
    }
    if(useTilt) window.addEventListener('deviceorientation', handleTilt, {passive:true});
  });

  // game loop
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if(running){
      t += dt;
      // ramp difficulty
      speed = 1.0 + Math.min(2.5, t*0.15);
      gateWidth = Math.max(0.22, 0.7 - t*0.06);

      // move gate occasionally
      wobble += dt;
      if(wobble > 0.8){
        wobble = 0;
        gateAngle += (Math.random()*2-1) * 0.9;
      }
      // scoring and collision (angular check)
      score += dt * Math.floor(speed*60);
      scoreEl.textContent = Math.floor(score).toString();

      const PI = Math.PI;
      // wrap angles
      const wrap = a => {
        if(a>PI) a-=2*PI;
        if(a<-PI) a+=2*PI;
        return a;
      };
      gateAngle = wrap(gateAngle);
      playerAngle = wrap(playerAngle);

      let d = Math.abs(playerAngle - gateAngle);
      d = Math.min(d, 2*PI - d);
      if(d > gateWidth){     // missed the gap
        running = false;
        startOverlay.style.display = 'flex';
        btn.textContent = 'Retry';
        // brief flash
        scoreEl.textContent = `Score: ${Math.floor(score)}`;
      }
    }

    // draw shader
    gl.useProgram(prog);
    gl.uniform2f(uR, canvas.width, canvas.height);
    gl.uniform1f(uT, t);
    gl.uniform1f(uSpeed, speed);
    gl.uniform1f(uGateA, gateAngle);
    gl.uniform1f(uGateW, gateWidth);
    gl.uniform1f(uPlayerA, playerAngle);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>